/**
 * @fileoverview Project and Image Management Routes.
 * Provides REST API endpoints for managing user projects and their associated images.
 * This includes CRUD operations for projects, and CRUD operations for image metadata.
 * Image file uploads are handled via client-side uploads to GCS using signed URLs generated by `/api/gcs` routes;
 * this module then handles the registration and management of that image metadata.
 * It also provides endpoints to update OCR and Analysis details for images, typically invoked by other backend processes
 * or for client-side manual edits.
 * All routes are authenticated and rely heavily on `projectService` for database interactions
 * and the GCS client for deleting image files from storage.
 * @module routes/projects
 */
const express = require('express');
const router = express.Router();
const firebaseAdmin = require('firebase-admin');

const projectService = require('../services/projectService');
const invoiceService = require('../services/invoiceService');
const projectImagesRouter = require('./projectImages');
const { addSseClient } = require('../services/sseService');
const logger = require('../config/logger');
const authenticateUser = require('../middleware/authenticateUser');

// Firebase Admin SDK initialization check
if (firebaseAdmin.apps.length === 0) {
  console.warn('[Routes/Projects] Firebase Admin SDK has not been initialized. Authentication will fail.');
}

// Check if invoiceService is available
if (!invoiceService) {
  logger.error('[Routes/Projects] CRITICAL ERROR - invoiceService was not imported or is unavailable (needed for SSE).');
  // Depending on startup strategy, might throw an error to prevent app start
  // throw new Error('[Routes/Projects] invoiceService is critical and not available.');
  }

// Apply authentication middleware to all routes in this router
router.use(authenticateUser);

/**
 * @route GET /api/projects/
 * @summary Get all projects for the authenticated user.
 * @description Retrieves a list of all projects belonging to the currently authenticated user.
 * The budget field for each project is parsed to a float.
 * @returns {object[]} 200 - An array of project objects.
 * @returns {Error} 500 - If there's an error fetching projects or the project service is not configured.
 * @example response - 200 - Success
 * [
 *   {
 *     "id": "uuid-project-1",
 *     "user_id": "firebase-user-uid",
 *     "title": "Summer Trip to Italy",
 *     "description": "Family vacation.",
 *     "location": "Italy",
 *     "start_date": "2024-07-10T00:00:00.000Z",
 *     "end_date": "2024-07-24T00:00:00.000Z",
 *     "budget": 3500.00,
 *     "is_completed": false,
 *     "created_at": "2024-01-15T10:00:00.000Z",
 *     "updated_at": "2024-01-15T10:00:00.000Z"
 *   }
 * ]
 */
router.get('/', async (req, res) => {
  try {
    const userId = req.user.id;
    logger.info(`[Routes/Projects] GET / - Attempting to fetch projects for user: ${userId}`);
    if (!projectService || typeof projectService.getUserProjects !== 'function') {
      logger.error('[Routes/Projects] projectService.getUserProjects is not available!');
      return res.status(500).json({ error: 'Project service not configured correctly.' });
    }
    const projects = await projectService.getUserProjects(userId);
    
    const projectsWithParsedBudget = projects.map(project => ({
      ...project,
      budget: project.budget !== null && project.budget !== undefined ? parseFloat(project.budget) : null
    }));
    
    res.status(200).json(projectsWithParsedBudget);
  } catch (error) {
    logger.error('[Routes/Projects] GET / - ERROR CAUGHT:', error);
    logger.error('[Routes/Projects] Error stack:', error.stack);
    res.status(500).json({ error: 'Failed to fetch projects' });
  }
});

/**
 * @route GET /api/projects/:projectId
 * @summary Get a specific project by ID.
 * @description Retrieves a single project by its ID, ensuring it belongs to the authenticated user.
 * The project's budget field is parsed to a float.
 * @param {string} req.params.projectId - The UUID of the project to retrieve.
 * @returns {object} 200 - The project object.
 * @returns {Error} 404 - If the project is not found or not owned by the user.
 * @returns {Error} 500 - If there's an error fetching the project or the project service is not configured.
 * @example response - 200 - Success
 * {
 *   "id": "uuid-project-1",
 *   // ... other project fields
 * }
 */
router.get('/:projectId', async (req, res) => {
  try {
    const userId = req.user.id;
    const projectId = req.params.projectId;
    logger.info(`[Routes/Projects] GET /${projectId} - Attempting to fetch project for user: ${userId}`);
    if (!projectService || typeof projectService.getProjectById !== 'function') {
      logger.error('[Routes/Projects] projectService.getProjectById is not available!');
      return res.status(500).json({ error: 'Project service not configured correctly.' });
    }
    const project = await projectService.getProjectById(projectId, userId);
    
    project.budget = project.budget !== null && project.budget !== undefined ? parseFloat(project.budget) : null;
    
    res.status(200).json(project);
  } catch (error) {
    logger.error(`[Routes/Projects] Error fetching project ${req.params.projectId}:`, error);
    if (error.statusCode === 404) {
      return res.status(404).json({ error: error.message });
    }
    if (error.statusCode === 403) {
      return res.status(403).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to fetch project' });
  }
});

/**
 * @route POST /api/projects/
 * @summary Create a new project.
 * @description Creates a new project for the authenticated user with the provided data.
 * The budget field is parsed to a float (defaults to 0 if parsing fails or not provided).
 * Other optional fields receive default values if not provided.
 * @body {object} projectData - The data for the new project.
 * @body {string} projectData.title - Title of the project (required).
 * @body {string} [projectData.description] - Description of the project.
 * @body {string} [projectData.location] - Location of the project.
 * @body {string} [projectData.start_date] - Start date (ISO 8601 format).
 * @body {string} [projectData.end_date] - End date (ISO 8601 format).
 * @body {number} [projectData.budget] - Budget for the project.
 * @body {boolean} [projectData.is_completed] - Completion status.
 * @returns {object} 201 - The newly created project object.
 * @returns {Error} 500 - If there's an error creating the project or the project service is not configured.
 * @example request body
 * {
 *   "title": "Weekend Getaway",
 *   "budget": 300
 * }
 * @example response - 201 - Success
 * {
 *   "id": "new-project-uuid",
 *   "user_id": "firebase-user-uid",
 *   "title": "Weekend Getaway",
 *   "budget": 300.00,
 *   // ... other fields with defaults
 * }
 */
router.post('/', async (req, res) => {
  try {
    const userId = req.user.id;
    logger.info(`[Routes/Projects] POST / - Attempting to create project for user: ${userId}`);
    if (!projectService || typeof projectService.createProject !== 'function') {
      logger.error('[Routes/Projects] projectService.createProject is not available!');
      return res.status(500).json({ error: 'Project service not configured correctly.' });
    }
    const projectData = {
      ...req.body,
      user_id: userId
    };
    
    if (projectData.budget !== null && projectData.budget !== undefined) {
      projectData.budget = parseFloat(projectData.budget);
      if (isNaN(projectData.budget)) {
        projectData.budget = 0;
      }
    }
    
    const project = await projectService.createProject(projectData);
    
    project.budget = project.budget !== null && project.budget !== undefined ? parseFloat(project.budget) : null;
    if (isNaN(project.budget)) {
      project.budget = null;
    }
    
    res.status(201).json(project);
  } catch (error) {
    logger.error('[Routes/Projects] Error creating project:', error);
    if (error.statusCode === 404) {
      return res.status(404).json({ error: error.message });
    }
    if (error.statusCode === 403) {
      return res.status(403).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to create project' });
  }
});

/**
 * @route PATCH /api/projects/:projectId
 * @summary Update an existing project.
 * @description Updates an existing project by its ID. Only the fields provided in the request body are updated.
 * The budget field is parsed to a float if provided.
 * @param {string} req.params.projectId - The UUID of the project to update.
 * @body {object} projectData - An object containing the project fields to update.
 * @returns {object} 200 - The updated project object.
 * @returns {Error} 404 - If the project is not found or not owned by the user.
 * @returns {Error} 500 - If there's an error updating the project or the project service is not configured.
 */
router.patch('/:projectId', async (req, res) => {
  try {
    const userId = req.user.id;
    const projectId = req.params.projectId;
    logger.info(`[Routes/Projects] PATCH /${projectId} - Attempting to update project for user: ${userId}`);
    if (!projectService || typeof projectService.updateProject !== 'function') {
      logger.error('[Routes/Projects] projectService.updateProject is not available!');
      return res.status(500).json({ error: 'Project service not configured correctly.' });
    }
    const projectData = req.body;
    
    if (projectData.budget !== null && projectData.budget !== undefined) {
      projectData.budget = parseFloat(projectData.budget);
      if (isNaN(projectData.budget)) {
        // Decide on behavior: error, or set to null/0? Current service sets to 0 if undefined.
        // For now, let service handle default if not a valid number, or frontend should ensure valid numbers.
        // Consider adding validation here if strictness is required.
      }
    }
    
    const updatedProject = await projectService.updateProject(projectId, projectData, userId);
    
    updatedProject.budget = updatedProject.budget !== null && updatedProject.budget !== undefined ? parseFloat(updatedProject.budget) : null;
    if (isNaN(updatedProject.budget)) {
      updatedProject.budget = null; // Ensure consistent null for bad float parse outcome
    }
    
    res.status(200).json(updatedProject);
  } catch (error) {
    logger.error(`[Routes/Projects] Error updating project ${req.params.projectId}:`, error);
    if (error.statusCode === 404) {
      return res.status(404).json({ error: error.message });
    }
    if (error.statusCode === 403) {
      return res.status(403).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to update project' });
  }
});

/**
 * @route DELETE /api/projects/:projectId
 * @summary Delete a project.
 * @description Deletes a project by its ID. This will also delete associated images and expenses due to CASCADE constraints in the database.
 * @param {string} req.params.projectId - The UUID of the project to delete.
 * @returns {} 204 - No content, indicating successful deletion.
 * @returns {Error} 404 - If the project is not found or not owned by the user.
 * @returns {Error} 500 - If there's an error deleting the project or the project service is not configured.
 */
router.delete('/:projectId', async (req, res) => {
  try {
    const userId = req.user.id;
    const projectId = req.params.projectId;
    logger.info(`[Routes/Projects] DELETE /${projectId} - Attempting to delete project for user: ${userId}`);
    if (!projectService || typeof projectService.deleteProject !== 'function') {
      logger.error('[Routes/Projects] projectService.deleteProject is not available!');
      return res.status(500).json({ error: 'Project service not configured correctly.' });
    }
    const result = await projectService.deleteProject(projectId, userId);
    res.status(200).json({ message: 'Project deleted successfully', id: result.id });
  } catch (error) {
    logger.error(`[Routes/Projects] Error deleting project ${req.params.projectId}:`, error);
    if (error.statusCode === 404) {
      return res.status(404).json({ error: error.message });
    }
    if (error.statusCode === 403) {
      return res.status(403).json({ error: error.message });
    }
    res.status(500).json({ error: 'Failed to delete project' });
  }
});

// --- Mount Image Sub-Router --- 
router.use('/:projectId/images', projectImagesRouter);

/**
 * @route GET /api/projects/:projectId/image-stream
 * @summary Establishes an SSE connection for real-time image updates for a project.
 * @description This endpoint establishes a Server-Sent Events (SSE) connection for real-time image updates for a specific project.
 * @param {string} req.params.projectId - The UUID of the project.
 * @returns {EventSource} 200 - SSE connection for real-time image updates.
 * @returns {Error} 500 - If there's an error establishing the SSE connection or the project service is not configured.
 */
router.get('/:projectId/image-stream', async (req, res) => {
  const projectId = req.params.projectId;
  const userId = req.user.id;

  logger.info(`[SSE] Connection attempt for project ${projectId} by user ${userId}`);

  // 1. Set SSE Headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('X-Accel-Buffering', 'no'); 
  res.flushHeaders(); 

  // 2. Add client to the list for this project
  try {
    await addSseClient(projectId, userId, res);
  } catch (error) {
    logger.error(`[SSE] Error in addSseClient for project ${projectId}, user ${userId}:`, error);
    if (!res.writableEnded) {
      // Politely inform the client of an error if possible, then close.
      // Avoid sending a full HTML error page. A simple message or custom event type might be best.
      try {
        res.write('event: error\ndata: {"message": "Failed to initialize image stream due to server error."}\n\n');
      } catch (writeError) {
        logger.error('[SSE] Error writing error event to SSE client:', writeError);
      }
      res.end();
    }
    return; // Stop further processing for this request
  }

  // 3. Handle client disconnect
  req.on('close', () => {
    logger.info(`[SSE] Client disconnected for project ${projectId}, user ${userId}. (Note: sseService handles removal if needed)`);
    // sseService.removeSseClient(projectId, userId, res); // Or however removal is handled
  });
});

module.exports = router; 